---


---

<h1 id="文件系统">文件系统</h1>
<h2 id="文件、目录">文件、目录</h2>
<h3 id="概念...">概念…</h3>
<h3 id="补充inode">补充inode</h3>
<h4 id="简介">简介</h4>
<ul>
<li>文件数据是储存在硬盘上的，硬盘的最小存储单位叫做扇区。每个扇区存储512字节，而连续的8个扇区组成了一个块（block），大小为4kB。文件数据都存储在块中，为了能够方便找到存储数据的位置我们还必须找到一个地方存储文件的属性，这种存储文具属性信息的区域叫做inode（索引节点）。</li>
<li>inode（本质上是一个结构体）包含文件的属性信息有以下内容：注意，没有文件名和inode编号<br>
文件的字节数<br>
文件拥有者的id<br>
文件所属组id<br>
文件的读写执行权限<br>
文件的时间戳，共有三个：<br>
ctime指inode上一次变动的时间<br>
mtime指文件内容上一次变动时间<br>
atime指文件上一次打开时间。<br>
硬链接数，即有多少个文件指向这个inode<br>
文件数据块（block）的位置，即指向数据块的指针，包括一级指针，二级指针和三级指针，一般为15个指针</li>
<li>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘划分为两个区域。一个是数据区，存放文件数据，另一个是inode区（inode table），存放inode所包含的信息，inode区本质上是一个结构体数组，数组下标就是inode编号inode_num。</li>
</ul>
<p><img src="https://kisugitakumi.net/images?fileName=/img20/image-20221205182107212.png" alt="image-20221205182107212"><br>
inode编号是很重要的，当系统在找一个文件时，步骤如下：</p>
<p>通过文件名先找到文件的inode编号（数组下标）<br>
通过inode编号找到文件inode节点（结构体）<br>
通过inode节点中的block指针找到文件内容、</p>
<h4 id="硬链接、符号链接">硬链接、符号链接</h4>
<ul>
<li>一般情况下，文件名和inode号码是一一对应关系，每个inode号码对应一个文件名，但是Linux系统允许多个文件名指向同一个inode号码，这就意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是删除一个文件名，不影响另一个文件名访问，相当于源文件的副本，这种情况叫做硬链接。<br>
inode信息中有一项叫做链接数，记录指向该inode的文件总数，这时会加1，反过来，删除一个文件名，会减一，当链接数变为0时，表明没有文件指向这个inode号码，系统就会回收这个inode号码与文件数据块区。</li>
<li>文件A与文件B的号码虽然不一样，但是文件A的内容是文件B的路径，A就是B的软链接文件。读取文件A时，系统会自动访问导向文件B的文件名，然后再根据B的inode去访问存储在块中的数据。<br>
而这意味着，文件A依赖于文件B而存在，若删除了文件B，打开文件A就会报错。这就是软连接与硬链接最大的不同：文件A指向文件B的文件名，而不是inode号码，文件B的inode链接数不会发生变化。</li>
</ul>
<h3 id="stat">stat</h3>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> stat <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> stat <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">lstat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">struct</span> stat <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre>
<ul>
<li>stat：第一个形参：文件路径（文件名）； 第二个形参：一个指向结构体stat的指针，因此需要传入结构体的地址；</li>
<li>fstat：第一个形参是文件描述符；</li>
<li>lstat：lstat函数的形参跟stat函数的形参一样。其功能也跟stat函数功能一样，仅有一点不同：stat函数是穿透（追踪）函数，即对软链接文件进行操作时，操作的是链接到的那一个文件，不是软链接文件本身；而lstat函数是不穿透（不追踪）函数，对软链接文件进行操作时，操作的是软链接文件本身。注：软链接严格来说应该叫符号链接。<br>
返回值：成功返回0，失败返回-1，并且将详细错误信息赋值给errno全局变量。</li>
</ul>
<pre class=" language-c"><code class="prism  language-c"><span class="token keyword">struct</span> stat <span class="token punctuation">{</span>
  dev_t st_dev<span class="token punctuation">;</span>     <span class="token comment">/* 文件的设备编号 */</span>
  ino_t st_ino<span class="token punctuation">;</span>     <span class="token comment">/* 索引结点编号 */</span>
  mode_t st_mode<span class="token punctuation">;</span>    <span class="token comment">/* 文件类型和权限*/</span>
  nlink_t st_nlink<span class="token punctuation">;</span>   <span class="token comment">/*硬链接数 */</span>
  uid_t st_uid<span class="token punctuation">;</span>     <span class="token comment">/*用户ID*/</span>
  gid_t st_gid<span class="token punctuation">;</span>     <span class="token comment">/* 组ID*/</span>
  dev_t st_rdev<span class="token punctuation">;</span>    <span class="token comment">/* 设备类型（若此文件为设备文件，则为设备编号*/</span>
  off_t st_size<span class="token punctuation">;</span>    <span class="token comment">/* 文件大小，以字节为单位*/</span>
  blksize_t st_blksize<span class="token punctuation">;</span> <span class="token comment">/*文件系统的I/O块大小*/</span>
  blkcnt_t st_blocks<span class="token punctuation">;</span>  <span class="token comment">/* 块数 */</span>
  time_t st_atime<span class="token punctuation">;</span>   <span class="token comment">/* 访问时间 */</span>
  time_t st_mtime<span class="token punctuation">;</span>   <span class="token comment">/* 修改时间 */</span>
  time_t st_ctime<span class="token punctuation">;</span>   <span class="token comment">/* 更改时间 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

</code></pre>
<h3 id="空洞文件">空洞文件</h3>
<ul>
<li>
<p>使用 lseek 可以修改文件的当前读写位置偏移量，此函数不但可以改变位置偏移量，并且还允许文件偏移量超出文件长度，譬如有一个 test_file，该文件的大小是 4K（也就是 4096 个字节），通过 lseek 系统调用可以将该文件的读写偏移量移动到偏移文件头部 6000 个字节处。</p>
</li>
<li>
<p>接下来使用 write 函数对文件进行写入操作，也就是说此时将是从偏移文件头部 6000 个字节处开始写入数据，也就意味着 4096~6000 字节之间出现了一个空洞，因为这部分空间并没有写入任何数据，所以形成了空洞，这部分区域就被称为文件空洞，那么相应的该文件也被称为空洞文件。文件空洞部分实际上并不会占用任何物理空间，直到在某个时刻对空洞部分进行写入数据时才会为它分配对应的空间，但是空洞文件形成时，逻辑上该文件的大小是包含了空洞部分的大小的，这点需要注意。</p>
</li>
</ul>
<h3 id="文件访问权限">文件访问权限</h3>
<ul>
<li>st_mode是一个16位的位图，用于表示文件类型，文件访问权限以及特殊权限位。<br>
它的类型为mode_t，其实就是普通的unsigned int，但是只是用了低16位。<br>
<img src="https://kisugitakumi.net/images?fileName=/img20/image-20221205165451681.png" alt="image-20221205165451681"><br>
dcb-lsp7种类型</li>
</ul>
<pre><code>//bit15 ~ bit12 , 文件类型属性区域
#define S_IFMT  0170000   // 文件类型掩码
#define S_IFSOCK 0140000  // socket
#define S_IFLNK  0120000  // 符号链接
#define S_IFREG  0100000  // 普通文件
#define S_IFBLK  0060000  // 块设备
#define S_IFDIR  0040000  // 目录
#define S_IFCHR  0020000  // 字符设备
#define S_IFIFO  0010000  // FIFO

#define S_ISSOCK(m) (((m) &amp; S_IFMT) == S_IFSOCK)  //提供了一些宏函数来帮助用户执行&amp;操作，是则返回1
#define S_ISLNK(m)  (((m) &amp; S_IFMT) == S_IFLNK)  
#define S_ISREG(m)  (((m) &amp; S_IFMT) == S_IFREG)
#define S_ISBLK(m)  (((m) &amp; S_IFMT) == S_IFBLK)
#define S_ISDIR(m)  (((m) &amp; S_IFMT) == S_IFDIR)
#define S_ISCHR(m)  (((m) &amp; S_IFMT) == S_IFCHR)
#define S_ISFIFO(m) (((m) &amp; S_IFMT) == S_IFIFO)

//bit11 ~ bit9，权限的特殊属性区域
#define  S_ISUID      0004000     文件的(set user-id on execution)位
#define  S_ISGID      0002000     文件的(set group-id on execution)位
#define  S_ISVTX      0001000     文件的sticky位

//bit8 ~ bit0，权限属性区域
//文件所有者（owner）
#define S_IRWXU 00700	/* mask for file owner permissions */
#define S_IRUSR 00400	/* owner has read permission */
#define S_IWUSR 00200	/* owner has write permission */
#define S_IXUSR 00100	/* owner has execute permission */
 //组用户（group）
#define S_IRWXG 00070	/* mask for group permissions */
#define S_IRGRP 00040	/* group has read permission */
#define S_IWGRP 00020	/* group has write permission */
#define S_IXGRP 00010	/* group has execute permission */
 //其他用户（other）
#define S_IRWXO 00007	/* mask for permissions for others (not in group) */
#define S_IROTH 00004	/* others have read permission */
#define S_IWOTH 00002	/* others have write permission */
#define S_IXOTH 00001	/* others have execute permission */
</code></pre>
<h3 id="umask">umask</h3>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
mode_t <span class="token function">umask</span><span class="token punctuation">(</span>mode_t mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>在进程创建一个新的文件或目录时，如调用open函数创建一个新文件，新文件的实际存取权限是mode与umask按照 mode &amp; ~umask运算以后的结果。umask函数用来修改进程的umask，作用是防止出现权限过松的文件。</p>
<h3 id="文件权限的更改管理">文件权限的更改/管理</h3>
<pre class=" language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">chmod</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">fchmod</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>chmod是对指定的文件进行操作，而fchmod则是对已经打开的文件进行操作。所以它们的第一个参数不一样。</p>
<p>返回值：如果改变成功返回0，否则返回-1</p>
<h3 id="粘住位">粘住位</h3>
<h3 id="文件系统fatufs">文件系统:FAT,UFS</h3>
<p>文件系统:文件或数据的存储或管理</p>
<h3 id="链接">链接</h3>
<ul>
<li>链接分为硬链接和符号链接（注意不是软链接）。</li>
</ul>
<h3 id="utime">utime</h3>
<h3 id="目录的创建和销毁">目录的创建和销毁</h3>
<h3 id="更改当前工作路径">更改当前工作路径</h3>
<h3 id="分析目录读取目录内容">分析目录/读取目录内容</h3>
<h2 id="系统数据文件和信息">系统数据文件和信息</h2>
<h2 id="进程环境">进程环境</h2>

